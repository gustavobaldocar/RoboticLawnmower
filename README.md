# Project: 
# Automated Robotic Lawnmower Simulator
# MVP with K8s Scaling and CI/CD
#
#
# Author: gustavobaldocarvalho @ yahoo.com
#
# Version: 31.01.2026 - Creation

---

# Robotic Lawnmower Simulator

This project is a Minimum Viable Product (MVP) for an Automated Robotic Lawnmower Simulator, 
designed to verify mowing paths generated by algorithm teams.

## Phase 0: Requirements Review

* Review file *Robotic Lawnmower Homework - Orbitworks - Confluence.pdf*
* Extract required Core Logic (The Simulator)
* Extract required CLI and API Logic (The Simulator support service)

### Functional Requirements & Rules

* **Lawn Grid**: The lawn must be a rectangular 2D grid of uniform squares.
* **Square Types**: Each square must be categorized as **Uncut grass** (default), **Cut grass**, or **Rock**.
* **Starting Position**: The mower always starts at the top-left corner `[0,0]`, which is guaranteed not to be a rock.
* **Movement**: The mower occupies one square and can move exactly one square at a time in four directions (Up, Down, Left, Right).
* **Mowing Logic**: Landing on Uncut grass changes it to Cut grass; landing on Cut grass has no effect.
* **Termination (Crash)**: The simulation ends immediately if the mower lands on a **Rock** or goes **off the grid** (fences).

* **Mandatory Outputs**: The simulator must answer three specific questions:
1. Was all the grass cut? 
2. If not, how much uncut grass remained? 
3. Did the lawnmower crash? 

### Input & Output Specifications

* **Input Data**: The application must receive the lawn dimensions, locations of rocks/grass, and the sequence of steps for the mower.
* **API**: While GraphQL is preferred by the algorithms team, they accept REST or other common web-based APIs.

### Technical & Submission Requirements

* **Environment Isolation**: You must use **Docker** to isolate the environment.
* **Docker Components**: You must provide a **Dockerfile**, the ability to build a Docker image, and the ability to run the image.
* **Language**: The application must work with **Python  3.9**.
* **Documentation**: Submissions must include documentation regarding program usage, design, and inline logic.
* **Testing**: You must write Python tests and provide an easy way to run them.
* **Git Submission**: Work must be submitted via a private Git repository (GitHub/GitLab) with specific access granted to evaluators.

### Extensions (Above and Beyond)

* **Simultaneity**: Scale the app to handle 100+ simultaneous requests.
* **Kubernetes**: Provide a way to deploy on K8s with the ability to scale up (more resources per pod) and scale out (more pods).
* **CI/CD**: Add an automated pipeline for linting, type checking (mypy), and running tests.

## Phase A-B: Design Definition

* The system follows a **Unified Core** architecture in python where a single engine handles logic and
can be exposed via CLI and FastAPI.

* The Core Engine object is instantiated from **LawnmowerSim** defined class using inputs to define 
the grid, its obstacles (rocks), start position and test name.

* The Core Logic instantiate the Core Engine and returns results as Terminal printout and structure
for input data in dictionary format

* The CLI Logic can run with a hard coded default scenario without inputs.

* Both CLI and API Logic use input files with information in text form from ./tests folder
and convert them into dictionary to be passed to a core Logic

* Both CLI and API Logic receive return from core Logic in structure format and 
convert it to JSON Files in ./results folder

* Obs: For sake of simplicity, the input error Handling was descoped from this first version in both 
Core Engine and App Logic.

## Phase C: Detailed Design and Implementation

### Folder Structure

* Requirements:
* **`./requirements`**: Contains the requirements document  

* Python Code:
* **`./python`**: Contains the core simulation engine (`lawnmower_sim.py`), unit tests for core logic (`lawnmower_sim_test.py`) and the unified APP-API/CLI entry point Logic (`lawnmower_cli_api.py`) and also browser UI definitions (`lawnmower_api.html`)  

* Simulator Tests:
* **`./tests`**:  Contains various scenario configuration `.txt` files.  

* Simulator Results:
* **`./results`**: The local output directory where simulation results are saved as timestamped `.json` files.  

* Docker:
* **`./docker`**: Contains the Dockerfile definition and the Docker environment requirements.  

* Kubernetes:
* **`./k8s`**: Contains Kubernetes manifests, including Deployment, Service, and Horizontal Pod Autoscaler (HPA) configurations.  

* Root folder files:
* `README.md` file
* `mypy.ini` (see Python CI/CD Checking Setup)

* GitHub Local Simulation:
* **`.github`**: the GitHub infrastructure Local Test
* **`.github/workflows`**: the GitHub infrastructure Local Test
* .github/workflows/ci.yml (see Python CI/CD Checking Setup)

### Python Setup

* Download and install Python version >= 3.9 from the official website (python.org). (Tip: better 3.12)
* Ensure you check the box "Add Python to PATH" during installation.
* Install Project Dependencies: 
    ```python -m pip install -r ./docker/lawnmower_sim_docker_requirements.txt```

### Python Auto-Test Setup (pytet)

* Install Testing Tool: 
    ```python -m pip install pytest```

### Python Integrity Checks (mypy)

* Install Git integrty Check: 
    ```python -m pip install mypy```
* Upgrade Python integrty:  
    ```python -m pip install --upgrade mypy```
* mypy requires the ./mypy.ini in project root to define type-checking rules 

### Git CI/CD Checking Setup

* CI/CD requires the ./ci.yml in project root to configure the CI/CD capability 
to automate the Python Integrity Checks (mypy) and the Docker/k8s build/test cycle
for git platform

#### Simulate Git CI/CD Checking Setup

* act app reads your ci.yml and pulls Docker images that mimic GitHub's runners.
* Using Powershell in admin mode
    ```Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))```
* Install: 
    ```choco install act-cli```
* Build infrastructure for Github
    ```mkdir .github
    mkdir .github/workflows
    docker pull catthehacker/ubuntu:act-latest```
        
### Implementation

* From a Bottom up perspective, the Core Engine (`lawnmower_sim.py`) is the Simulator itself.
* It is defined by class definition for object oriented instantiation.
* It requires following inputs:
    `test_name (str):` test name
    `grid_height (int):` The total number of rows in the lawn.
    `grid_width (int):` The total number of columns in the lawn.
    `rock_locations (List[List[int]]):` Y,X coordinates of rocks within the grid.
    `start_pos (List[int]):` The starting coordinate [Y, X] for the mower.
* The Core Engine implements following functionalities:
* **Grid Logic**: At instantiation it defines boundaries and filters out rocks located outside the grid, issuing warnings if detected.
* **Core Engine**: Uses a "Coordinate-First, Validate-Second" approach to ensure crash locations are recorded in `pos_history` before termination.
* **Crash Detection**: Monitors for **Rock Crashes** and **Fence Crashes**.
* **Progress Tracking**: Tracks unique cells visited and calculates uncut grass remaining to determine mission success.
* **Log/Report**: Collect all messages generated during the test

* The Isolated Core Engine allows for a simulator Logic test (`lawnmower_sim_test.py` pytest) without bodering about specific 
input and output formats, allowing to focus only in the Logic.

* The Core Engine is called by The APP Entry Point Core Logic (`lawnmower_cli_api.py`) implemented by a function that receives data in python Dictionary 
* The result from Core Engine is then formanted into JSON files in ./results folder

* The APP Entry Point Core Logic can be called by 2 different functions/modes: CLI and API.
* Both modes receive input file in text format with test definitions. Here Example of a definition file:
    `test_name="lawnmower_scenario01_valid"`
    `height=5`
    `width=5`
    `rocks=[[1,1], [2,2], [3,3]]`
    `start_pos=[0,0]`
    `path=["Down", "Down", "Down", "Right", "Up", "Left"]`

* The API Mode implements a browser UI which allows
* Uploads .txt definitions to the backend for processing.
* Live Visualization: Renders a dynamic grid, rock obstacles, and mower pathing on an HTML5 canvas.
* Result Analysis: Displays crash alerts or success messages and allows downloading and visualisation of 
simulation data as JSON.
* Instant Documentation: Includes an "ABOUT" modal that fetches and displays the README.md file.

* The APP was constructed using FastAPI for more simplicity, Native File Upload capabilities
and avoiding need for aditional schema validation steps in CI/CD

* Run the type check 
    ```python -m mypy ./python/lawnmower_cli_api.py ./python/lawnmower_sim.py ./python/lawnmower_sim_test.py```

### Docker Setup and Containerization 

* Ensures the application is portable and runs in an isolated environment
* Requirements
    * Define Docker Image requirements to be installed when image is created
        ```./docker/lawnmower_sim_docker_requirements.txt```
* Image Build
    * Ensure Docker Desktop Engine is running.
    * Image is a snapshot of a configuration that can be run to form a Docker container
    * It sets the working directory, copies docker requirements, installs dependencies 
    and then copies the application files (app/ directory)
    * Then is run API specifying the ports
    * Docker Images typically contains python:3.9-slim to keep the image lightweight
    * To Build docker image: 
        ```docker build -f ./docker/lawnmower_sim_dockerfile.dev -t lawnmower_sim_docker_image .```
        ```docker save -o ./docker/lawnmower_sim_image.tar lawnmower_sim_docker_image```
* Cotainer
    * An executing instantiation of the docker image
    * Because Docker containers are "ephemeral", files will disappear as soon as container is deleted
    * As such a mapping to host machne is required so the files can be kept 
    * To Run Docker image in a container with host port and folder mapping to container 
    put this in front of python commands: 
        * For PowerShell
            ```docker run -p 8000:8000 -v ${PWD}/results:/app/results lawnmower_sim_docker_image```
        * For CMD prompt
            ```docker run -p 8000:8000 -v %cd%/results:/app/results lawnmower_sim_docker_image```
        * Obs: This command alone already calls the API by default
    * To list all containers
        ```docker ps```
    * To list all docker images
        ```docker image ls```
    * To stop a container:
        ```docker stop $(docker ps -q)```
    * To delete a docker image:
        ```docker rmi lawnmower_sim_docker_image```

### Kubernetes Setup and Orchestration

* Handles deployment, scaling, and high availability of the simulator.
* Prep
    * Enable Kubernetes in Docker Desktop
    * Start Kubernetes Cluster (takes some min)
    * Install Metrics Server in the Cluster
        ```kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml```
        ```kubectl patch deployment metrics-server -n kube-system --type='json' -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"}]'```
    * Check Kubernetes: 
        ```kubectl cluster-info```
* k8s deployment: 
    * Specify how many copies (pods) of the docker container to run and their configuration.
    * Specify the Docker image to use and defines resource limits to ensure the container doesn't consume excessive CPU/Memory.
    * All the copies will run same API "waiting" for files simultaneously. If one crashes, Kubernetes automatically restarts it.
    * To Apply Deployment: 
        ```kubectl apply -f ./k8s/lawnmower_sim_k8s_deployment.yaml```
* k8s service:  		
    * Define K8s Service manifest with one unique network identity (single IP and port) for all the Pods
    * To Apply Service: 
        ```kubectl apply -f ./k8s/lawnmower_sim_k8s_service.yaml```
    * To List Pods Status: 
        ```kubectl get pods```
    * Check Service Access: 
        ```kubectl get service lawnmower-sim-service```
* k8s hpa: The Horizontal Pod Autoscaler. This automatically scales the number of pods based on CPU utilization to handle high-traffic test periods.
    * Define K8s Horizontal Pod Autoscaler (HPA) manifest
    * To Apply HPA: 
        ```kubectl apply -f k8s```
    * To get HPA status: 
        ```kubectl get hpa```
* k8s deployment, service and hpa:
    * To apply all in one go: 
        ```kubectl apply -f ./k8s```
        * Obs: When this is done, Pods are created with running containers.
        * Since Containers star API by default, the App is ready to be called from browser
    * To execute a cli:
        ```kubectl get pods -l app=lawnmower-sim
        kubectl exec <pod-name> -- python ./python/lawnmower_cli_api.py --cli
        kubectl exec <pod-name> -- python ./python/lawnmower_cli_api.py --cli ./tests/lawnmower_scenario01_valid.txt```
    * To check all:
        ```kubectl get all```
    * List the pods:
        ```kubectl get pods```
* k8s termination
    * To delete: 
        ```kubectl delete -f ./k8s*```
* Obs: When running in a Kubernetes cluster, you won't see printouts while running api server 
in your local terminal window because the Python process is running inside a remote Pod. 
However Core Logic Messages are stored in output JSON files.
This does not happen in case of using cli mode kubectl exec <pod-name>

* k8s Metric Server
    * Ensure the metrics-server is running: 
        ```kubectl get apiservices | grep metrics```

## Phase D: Tests

### 1. Isolated Python Tests

#### 1.1. Simulator Core Logic Automated Testing with Pytest

* This will Test only the Simulator Logic with Terminal Printouts.
* **Run All Tests**: 
    ```python -m pytest ./python/lawnmower_sim_test.py```
* **Run with Detailed Terminal printout Logs**: 
    ```python -m pytest -s ./python/lawnmower_sim_test.py```
* **Run 1-by-1**: 
    ```python -m pytest ./python/lawnmower_sim_test.py::test_scenario_01_valid_path```

#### 1.2. APP CLI and Core Logic Testing

* This will Test the Simulator wrapped by CLI interface with Terminal Printouts and Text File outputs.

##### 1.2.1 CLI with Default Scenario

* This is a Default Hard coded Scenario
* **Hardcoded Default Scenario**: 
    ```python ./python/lawnmower_cli_api.py --cli```

##### 1.2.2 CLI with Test Files

* This is a File based input Scenario
* **Scenario 01 (Valid)**: 
    ```python ./python/lawnmower_cli_api.py --cli ./tests/lawnmower_scenario01_valid.txt``` 
* *Expected Output*: "Still Gras to Cut"

* **Scenario 02 (Fence)**: 
    ```python ./python/lawnmower_cli_api.py --cli ./tests/lawnmower_scenario02_fence_crash.txt``` 
* *Expected Output*: "Termination: Crashed into Fence" 

* **Scenario 03 (Rock)**: 
    ```python ./python/lawnmower_cli_api.py --cli ./tests/lawnmower_scenario03_rock_crash.txt``` 
* *Expected Output*: "Termination: Crashed into Rock" 

* **Scenario 04 (Outside Start)**: 
    ```python ./python/lawnmower_cli_api.py --cli ./tests/lawnmower_scenario04_outside.txt``` 
* *Expected Output*: "WARNING: start pos at [10,10] is outside... Resetting to top left [0,0]"

#### 1.3. APP API and Core Logic Testing

* This will Test the Simulator wrapped by API interface with Terminal Printouts and Text File outputs.

* Start API Server: 
    ```python ./python/lawnmower_cli_api.py --api``` 

* **Friendly UI**:
1. Navigate to a browser
    ```http://localhost:8000``` 
2. Click **Load Definition** and select one of the `.txt` files from the `./tests` folder.
3. Click **Run Simulation** to see the status, path visualization, and crash reports on screen.
4. Click **Download Result** to save the final JSON to another Location in the host machine.
* Obs: Step 4 is optional as Files are already stored by default under ./results

### 2. Python Tests under Docker/Container environment

* Don't start Kubernetes yet. This test is targeted for only one Docker image first.
* Run all Tests under Section 1. above with Docker image.
* In a container with host port and folder mapping to container, put this commands below 
in front of python commands mention in section 1): 
    * For CMD prompt       
        ```docker run -p 8000:8000 -v ${PWD}/results:/app/results lawnmower_sim_docker_image```
    * For PowerShell
        ```docker run -p 8000:8000 -v %cd%/results:/app/results lawnmower_sim_docker_image```

### 3. Python Tests under Docker/Container in Kubernetes environment

* Stop all Docker containers to make sure we are really using k8s:
    ```docker stop $(docker ps -q)```
* Start Kubernetes:
    ```kubectl apply -f ./k8s```
* List the pods:
    ```kubectl get pods```
* List All Dockers: 
    ```docker ps```
    * See that now the docker processes are under k8s pods (k8s_lawnmower-sim-container_lawnmower-sim-deployment-...)
* Run all Tests using guidelins in Section 2 above. This time Docker image is managed by the K8s.

### 4. Kubernetes environment Tests

* Monitor the Scaling in Real-Time
    ```kubectl get hpa lawnmower-sim-hpa --watch```
* Generate Traffic with a Load Generator
    ```kubectl run -i --tty load-generator --rm --image=busybox --restart=Never -- /bin/sh -c "while sleep 0.001; do wget -q -O- http://lawnmower-sim-service:8000/simulate; done"```

* Saturation: As traffic increases, the TARGETS column in will rise from 0%/50% to values exceeding 50%.
* Upscaling: Once the threshold is crossed, the REPLICAS count will increase from your initial 3 up to a maximum of 10.
* Cooldown: After stop the load generator, HPA will wait for a "stabilization window" (default 5 minutes) before scaling back down to 2 replicas to conserve resources.

### 5. Git environment Tests

* When a push is done on git after a local commit to send code to the repository
* GitHub start a virtual python environment with all required dependencies
* to run Jobs in defined by ci.yml in proj root directory for the CI (continuous integration).
* In this project mypy integrity checks (defined by mypy.ini) for python code and 
pytest for sim logic were defined.

* Once the CI pipeline passes, the "CD" (Continuous Deployment) portion handles the delivery 
of the code to the production environment (Docker and K8s).
* The code is packaged into a Docker image.
* The image is deployed to a Kubernetes cluster.
* Dynamic Scaling: The Horizontal Pod Autoscaler (HPA) monitors the live pods.

* In Short:
* Git	triggers the pipeline on code changes.
* ci.yml	The "brain" of the automation; coordinates linting, typing, and testing.
    * mypy.ini	Defines the strictness of the type-checking gate.
* Dockerfile	Ensures the code runs exactly the same in the cloud as it does locally.
* Kubernetes	The execution platform; provides load balancing and autoscaling.

#### Simulate Git CI/CD Checking Setup

* Simulate a git push. This will simulate the push of git which triggers the CI/CD capabilities

* However, creating a docker inside of a docker is not supported and will make act fail
act is only to test  Python Logic (Integrity/Tests).
if we do not restrict its testing to only the CI part given by the "quality-assurance"
block in the ci.yml, it will fail because it tries to execute the Docker and k8s part as well
    ```act push --pull=false --job quality-assurance```
* If we get a "Job succeeded" it means code is fine and will pass at github CI part when pushed

* Test Docker build to confirm Dockerfile is valid and all paths match
    ```docker build -f ./docker/lawnmower_sim_dockerfile.dev -t lawnmower_sim_docker_image .```
    
* Test k8s and Scalability
    * Terminal1: Run k8s cluster
        ```kubectl apply -f ./k8s```
        ```kubectl get pods -l app=lawnmower-sim```
        There should be 3 pods running.
    * Terminal2: Monitor HPA
        ```kubectl get hpa lawnmower-sim-hpa --watch```
        watch the CPU load and number of pods
    * Terminal3: check number of pods
        ```kubectl top pods```  
        number of pods might change
    * Terminal4,5,6,7...: Generate Load in as many terminal needed to trigger scaling of pods
        ```# Get a valid test file from your project
        $testFile = "./tests/lawnmower_scenario01_valid.txt"
        $url = "http://localhost:8000/simulate"

        while($true) { 
            # Use curl.exe (built into Windows) which handles multipart boundaries perfectly
            curl.exe -X POST $url -F "file=@$testFile"
            
            Write-Host "Request sent at $(Get-Date)" -ForegroundColor Green
        }```

### Design to Requirements Traceability
        
1. Functional Requirements (The Simulator)
    * Lawn & Grid Logic: Successfully implements a 2D rectangular grid with Uncut, Cut, and Rock square types.
    * Movement & Rules: Correctly enforces the [0,0] start position, 4-direction movement, and mowing logic.
    * Termination: Includes robust logic to terminate and report reasons for both Rock Crashes and Fence Crashes.
    * Mandatory Outputs: The execute_path method returns the required answers: total grass cut, remaining uncut grass, and crash status.

2. Technical Requirements (Environment & API)
    * Language & Isolation: Built with Python 3.12 and isolated using Docker with a dedicated Dockerfile.
    * API Interface: Provides a FastAPI web service (REST) with a browser UI for configuration uploads and live path visualization.
    * Testing: Includes a pytest suite and a dedicated CLI mode for easy scenario validation.
    * Documentation: README.md is detailed, directly addressing the "Ease of following documentation" requirement.
            
3. Extensions (The "Above and Beyond")
    * CI/CD Pipeline: Automates linting, mypy type checking, and pytest via GitHub Actions.
    * Kubernetes & Scaling: Provides manifests for K8s deployment with a Horizontal Pod Autoscaler (HPA) that scales from 2 to 10 replicas based on CPU load.
    * Concurrency: Uses uvicorn with multiple workers to handle high-traffic simulation requests.
    
* Discrepancies and Future Development
    * Input Error Handling: As noted in code, input validation was descoped for the MVP. 
    * While acceptable for an MVP, adding basic checks for malformed .txt files would 
    enhance the "User Experience" criteria.

## Git Project Storage and Repository

1. Initialize and Prepare the Repository
    * Open a terminal in your project root
    
    * # 1. Initialize the local Git repository
    ```git init```

    * # 2. Add all files (including hidden folders like .github)
    ```git add .```

    * # 3. Create commit with a message
    ```git commit -am "Initial commit: Robotic Lawnmower Simulator MVP with K8s Scaling and CI/CD"```

2. Connect to GitHub
    * Login to GitHub
    * Create Repository RoboticLawnmower without License or Readme file
    
    * # 4. Link local folder to your remote GitHub repo
    ```git remote set-url origin https://github.com/gustavobaldocar/RoboticLawnmower.git
    git remote -v```
    
    * # 5. Set the branch name to main
    ```git branch --unset-upstream
    git branch -M main```
    
    * # 6. Push the code
    ```git push -u origin main --force```